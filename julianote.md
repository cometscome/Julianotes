物理で使う数値計算入門：Julia言語による簡単数値計算
=============

<div style="text-align: right;">
作成日　令和元年5月1日
</div>
<div style="text-align: right;">
更新日　令和元年5月11日
</div>
<div style="text-align: right;">
永井佑紀
</div>

目次
=
<!-- TOC -->

- [1. はじめに：このノートの目的](#1-はじめにこのノートの目的)
    - [1.1. Juliaの利点](#11-juliaの利点)
    - [1.2. 具体的な利点](#12-具体的な利点)
- [2. Juliaのインストール](#2-juliaのインストール)
    - [2.1. 二種類の実行方法](#21-二種類の実行方法)
    - [2.2. バージョン](#22-バージョン)
    - [2.3. Macの場合](#23-macの場合)
    - [2.4. Linuxの場合](#24-linuxの場合)
    - [2.5. Windowsの場合](#25-windowsの場合)
- [3. 基本編](#3-基本編)
    - [3.1. いじってみよう](#31-いじってみよう)
        - [3.1.1. 足し算、引き算](#311-足し算引き算)
        - [3.1.2. かけ算と割り算](#312-かけ算と割り算)
        - [3.1.3. あまり](#313-あまり)
        - [3.1.4. べき乗、指数関数、対数関数](#314-べき乗指数関数対数関数)
        - [3.1.5. 三角関数](#315-三角関数)
        - [3.1.6. 円周率](#316-円周率)
        - [3.1.7. 虚数](#317-虚数)
        - [3.1.8. 関数](#318-関数)
    - [3.2. 変数](#32-変数)
        - [3.2.1. 整数、実数、複素数](#321-整数実数複素数)
        - [3.2.2. 文字列](#322-文字列)
        - [3.2.3. ベクトルと行列](#323-ベクトルと行列)
    - [3.3. 数式をコードにしてみよう](#33-数式をコードにしてみよう)
        - [3.3.1. 関数の振る舞いをみる：forループとplot](#331-関数の振る舞いをみるforループとplot)
            - [3.3.1.1. forループ1](#3311-forループ1)
            - [3.3.1.2. forループ2](#3312-forループ2)
            - [3.3.1.3. ベクトルや行列の要素ごと計算](#3313-ベクトルや行列の要素ごと計算)
            - [3.3.1.4. プロット](#3314-プロット)
        - [3.3.2. 級数の和の計算：sumとリスト内包表記、If文、while文、引数の型、多重ディスパッチ](#332-級数の和の計算sumとリスト内包表記if文while文引数の型多重ディスパッチ)
            - [3.3.2.1. シンプルな場合:リスト内包表記](#3321-シンプルな場合リスト内包表記)
            - [3.3.2.2. forループによる足し算](#3322-forループによる足し算)
            - [3.3.2.3. 精度コントロール：If文とwhile文の紹介](#3323-精度コントロールif文とwhile文の紹介)
            - [3.3.2.4. 解析接続：引数の型の自由](#3324-解析接続引数の型の自由)
            - [3.3.2.5. 同じ名前の関数の定義：多重ディスパッチ](#3325-同じ名前の関数の定義多重ディスパッチ)
        - [3.3.3. 特殊関数](#333-特殊関数)
        - [3.3.4. 1次元数値積分](#334-1次元数値積分)
            - [3.3.4.1. 台形公式による積分](#3341-台形公式による積分)
            - [3.3.4.2. パッケージを使った数値積分](#3342-パッケージを使った数値積分)

<!-- /TOC -->

# 1. はじめに：このノートの目的
初めて数値計算をする人がJuliaを使って簡単にコードを書いて計算できるように、という意図で書いています。特に、物理で使うことの多い計算を中心にまとめています。

## 1.1. Juliaの利点

Juliaは2018年にバージョン1となったばかりの非常に新しいプログラミング言語ですので、様々なプログラミング言語の良いところを取り入れており、非常に<u>書きやすく</u>かつ<u>高速</u>です。また、FortranやCと違い、コンパイルが必要ありません。ですので、Pythonのようなスクリプト言語のように使うことができます。Pythonは現在非常に人気のある言語ですので、書籍も豊富でWebでの文献も多く、最初のプログラミング言語として勧められることも多いと思います。しかし、Pythonを数値計算で使う場合、特別な処置をしないと非常に遅いという問題があります。
そのため、Pythonで数値計算をすると遅いために、FortranやCを数値計算のための言語として勧められることも多いと思います。
Juliaは、「Pythonのように書きやすく」「FortranやCど同程度に速い」言語となるように設計されているために、数値計算を学ぶ際の最適な言語の一つになっています。

つまり、Juliaは

- FortranやCと同程度に高速
- Pythonと同じくらい書きやすく
- 数式を扱うようにコードを書くことができる

という言語です。

## 1.2. 具体的な利点
コードを見ればわかりますが、Julia の場合、Fortran や C で必要であったたくさんの「おまじない」や Lapackのインストールや呼び出しなどの煩雑なことを一切する必要がありません。Pythonでも似たような形でシンプルにコードが書けますが、Pythonは For ループが遅いという数値計算として使うには問題となる点(工夫すれば速くなりますが Python ならではのこの工夫を習得するのに時間がかかります）゙があります。この問題点のせいで、教科書に書いてあるようなアルゴリズムを Python にそのまま移植するととんでもなく遅くなってしまうことがあります。Python はあらかじめわかっているアルゴリズムを呼び出すことにかけてはそのライブラリの豊富さとコミュニティの広さで圧倒的ですが、新しいアルゴリズムを書いたりする場合には、最適ではないと思います。その点、Julia はアルゴリズムをそのままコードにするだけで速いです。これは、「物理以外の余計なことを考えずに物理の結果が知りたい」という、物理をやる人間にとって重要な欲求を満たす可能性のある言語となっている、ということですので、有望だと思います。


# 2. Juliaのインストール

## 2.1. 二種類の実行方法

Juliaを使うには、二つの方法があります。
1. 対話的実行環境　REPL(read-eval-print loop)
2. 通常の実行方法

1は、普通のアプリケーションのようにJuliaを起動して、その中でコードを書いたり計算をしたりプロットしたりするものです。簡単な計算を気軽に試すことができます。

2は、通常の実行方法で、ファイルにプログラムコードを```test.jl```みたいな形で保存してから、

```
julia test.jl
```
で実行する方法です。

このノートでは、最初は簡単なので1.のREPLを使います。少し複雑になってきた場合には、ファイルにコードを保存して、2.で実行することにします。




## 2.2. バージョン
このノートでのJuliaのバージョンは、1.1.0とします。

## 2.3. Macの場合

https://julialang.org/downloads/
から```macOS 10.8+ Package (.dmg)```をダウンロードして、他のアプリケーションと同様にインストールします。インストールしたあとは、アプリケーションにJulia 1.1がありますので、それをダブルクリックするとターミナルが起動して使えるようになります。

## 2.4. Linuxの場合
Linuxの場合には、

```
wget https://julialang-s3.julialang.org/bin/linux/x64/1.1/julia-1.1.0-linux-x86_64.tar.gz
tar -xvf julia-1.1.0-linux-x86_64.tar.gz
echo 'export PATH="$PATH:$HOME/julia-1.1.0/bin"' >> ~/.bashrc
source ~/.bashrc
```
でインストールができますので、あとは

```
julia
```
で起動することができます。

## 2.5. Windowsの場合
Windows版のJuliaをインストールすれば使用できます。あるいは、Windows Subsystem for Linuxを使ってUbuntuを入れることで上のLinuxと同じようにインストールすることもできます。


# 3. 基本編
この章では、REPLの上でJuliaを使ってみましょう。
## 3.1. いじってみよう
まずはじめに、プログラミング言語での定番、Hello worldですが、これは、

```julia
println("Hello World!")
```
で出力されます。
ここで、```println```は最後に改行あり、```print```は改行なしです。
関数の説明がみたい時には、?を押すとHelpモードに入りますので、そこで関数名を入れます。

なお、REPLを終了するには、

```julia
exit()
```
とします。

### 3.1.1. 足し算、引き算
足し算は、

```julia
1+2
```
でできますし、引き算は

```julia
2-5
```
でできます。

### 3.1.2. かけ算と割り算
かけ算は、```*```の記号で、

```julia
2*3
```
となりますし、割り算の記号は```/```で、

```julia
4/2
```
でできます。
割り算については注意があります。上の計算を行うと、

```
2.0
```
となりました。2と2.0の違いは、整数と実数の違いです。
もちろん、計算機では無限の桁の実数を扱うことはできませんから、この実数は桁があります。それについては後述します。
もし、割った結果を整数で欲しい場合には、

```julia
div(4,2)
```
とすると、答えとして```2```が返ってきます。


### 3.1.3. あまり
割り算のあまりを計算することもできます。その場合には、```%```を使います。

```julia
5%2
```
とすると、5わる2のあまりである1が出ます。

### 3.1.4. べき乗、指数関数、対数関数
べき乗は```^```でできますので、

```julia
3^7
```
となります。
指数関数は```exp```で、

```julia
exp(3)
```
でできますし、自然対数は```log```で

```julia
log(2)
```
となります。対数の底が2と10の時はそれぞれ```log2```と```log10```が使えて、

```julia
log2(4)
```
や
```julia
log10(100)
```
が使えます。任意の底の場合には、nを底、xを値として、```log(n,x)```で使えまして、

```julia
log(3,9)
```
となります。

### 3.1.5. 三角関数
三角関数も普通に使うことができます。
例えば、

```julia
sin(0.1)+2*cos(0.3)
```
などができます。もちろん、tanhなども使えます。

### 3.1.6. 円周率
円周率はデフォルトで入っています。日本語の漢字変換で「ぱい」としてπを入力するか、REPL上で```\pi```としてからタブキーを押すことでπを使うことができますので、

```julia
cos(3π)
```
というような形で書くことができます。
ここで、```3π```と書きましたが、かけ算の記号```*```を使って```3*π```と書くこともできます。後述しますが、数字と記号の積の場合には、記号```*```を省略して書くことできます。
これにより、より数式に近い見た目になります。

### 3.1.7. 虚数
虚数も複素数も簡単に扱うことができます。
虚数単位は```im```です。ですので、

```julia
4 + 5im
```
などと書きます。なお、円周率と同様に、```5*im```は```5im```と記号```*```を省略できます。
三角関数と組み合わせれば、

```julia
exp(im*π)
```
とすることもできます。
なお、この計算を行うと、結果は

```julia
-1.0 + 1.2246467991473532e-16im
```
のような形で表示されていると思います。この値は厳密には-1になるべきですが、すごく小さい虚数が入っています。これは、計算機の中の実数が本当の実数ではないことと関連していまして、ここで使われている数の桁数が16桁（倍精度実数と呼びます）であることを意味しています。
なお、より精度の高い計算をするための方法も実装されていまして、

```julia
exp(im*BigFloat(π))
```
と```BigFloat```を使うと、

```julia
-1.0 + 1.096917440979352076742130626395698021050758236508687951179005716992142688513354e-77im
```
とより精度の高い計算をすることができます。

### 3.1.8. 関数
次に、自分で定義した関数を使うことを考えます。
例えば、

$$
f(x)= \cos(x)+2\sin(x^2)
$$
という関数であれば、

```julia
f(x) = cos(x) +2*sin(x^2)
```
とそのまま関数を定義することができます。そして、例えばx=4での値などが知りたい場合には、

```julia
f(4)
```
とすれば出ます。

この```f(x)```をfunction、つまり関数と呼びます。上では一行で関数を定義しましたが、もう少し複雑な場合には、

```julia
function f(x)
    cos(x) +2*sin(x^2)
end
```
とすることができます。この形の関数については後述します。

ここまでで、電卓的な使い方を一通り見ることができました。

## 3.2. 変数
次は、変数を紹介します。
先ほどの関数
$$
f(x)= \cos(x)+2\sin(x^2)
$$
を
$$
f(x)= \cos(x)+a\sin(x^2)
$$
にしてみましょう。もし、この関数f(x)がaに依存しているならば、
$$
f(x,a)= \cos(x)+a\sin(x^2)
$$
と書くことも可能です。
このコードは、

```julia
f(x,a) = cos(x) +a*sin(x^2)
```
とそのままに書くことができます。ここで、あらかじめaに値を入れておけば、

```julia
a = 3
f(4,a)
```
などと書けます。このaを「変数」と呼びます。

変数には様々なものを入れることができます。
### 3.2.1. 整数、実数、複素数
整数、実数、複素数であれば、

```julia
a = 3
b = 2.3
c = 4+5im
```
のようになります。これらはそれぞれ演算ができて、

```julia
a*b + c/a
```
は複素数が出てきます。
また、変数の記号として、アルファベット以外も使うことができます。
例えば、

```julia
H = 1.2
β = 2
Z = exp(-β*H)
```
でのβのようなギリシャ文字や、

```julia
りんご = 30
みかん = 20
りんご*2 + みかん*3
```
のような日本語も使用可能です。このように変数に様々な文字が使えるので、物理に出てくる数式をほとんどそのままコードとして書くことができます。

### 3.2.2. 文字列
変数には文字を入れることができます。
例えば、

```julia
a = "Warrior"
b = "Magic"
c = b*a
println(c)
```
とすると、出力として、```MagicWarrior```が出てきます。
注意点としては、文字列と文字列を合体させるときには、積の記号と同じ```*```を使うことです。これは、文字列の合体は非可換な積であるというコンセプトのもとに設定されているようです。なお、Pythonでは```+```を使います。


### 3.2.3. ベクトルと行列
物理の数値計算をするのであれば避けて通れないのは、ベクトルと行列です。ですので、変数にベクトルや行列を入れることができます。
Juliaでは、ベクトルは

```julia
a = [1,2,3,4]
```
と書くことができます。そして、行列は

```julia
B = [1 2 3 4
5 6 7 8]
```
と書くことができます。ここでBは2x4行列です。行列の要素同士はスペースで区切ります。また、

```julia
B = [1 2 3 4;5 6 7 8 ]
```
のように、改行の代わりに```;```を使うこともできます。

2x4行列と4成分ベクトルの積は

```julia
B*a
```
と通常の積の記号```*```でできます。
n成分ベクトルはnx1行列とみなすことができるので、

```julia
c = [1
2
3
4]
```
と書くこともできます。

サイズの大きい行列を定義するのにいちいち全部行列要素を書くのは大変です。ですので、まとめて扱う方法があります。
例えば、3x3の零行列は

```julia
B = zeros(3,3)
```
と定義することができます。もし、ほとんどがゼロの行列で一部だけ何か値がある場合には、

```julia
B[1,2] = 4
println(B)
```
とします。ここで、```B[1,2]```は、1行2列目の行列要素です。
Juliaでは、行列の要素は1から数えます。3x3行列であれば、1,2,3、となります。Pythonは0から数え0,1,2ですので、違いに気をつけてください。

さて、零行列Bを定義した後に、その一部の行列要素が複素数である場合を考えます。その場合、

```julia
B = zeros(3,3)
B[1,2] = 4 + 2im
```
はエラーが出てしまいます。何が問題なのでしょうか？

問題は、

```julia
B
```
としてみるとわかります。
これを打ってみると、

```julia
3×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0
```
となります。この```Array```が、Bが行列であることを意味しています。Arrayは```A[1,2,3]```のような3つ以上の足をつけることができますので、配列、と呼ばれています。
Bは```3×3 Array{Float64,2}```のようです。
ここで、```3x3```は3x3行列であることを意味しています。次の```Array{Float64,2}```は、行列要素の中身が```Float64```であり、足が２つある、ということを意味しています。```Float64```とは、倍精度実数であり、変数の種類のことをさします。
例えば、

```julia
 C = [1 2
       3 4]
```
とすると、

```julia
2×2 Array{Int64,2}:
 1  2
 3  4
```
となりまして、```Array{Int64,2}```は、行列要素の中身が```Int64```であることを意味しています。つまり、行列要素が整数、ということを言っています。
このような変数の種類のことを「型」と言います。
先ほどの行列Bは行列要素がFloat64でなければならない、ということです。ただし、
```julia
B = zeros(3,3)
B[1,2] = 4 
```
は可能です。4は整数ですが、整数から実数へは変換することができます。4が4.0になるわけです。しかし、```4+2im```のような複素数の場合、これは実数に変換できません。そのため、エラーが出ました。
これを解決するためには、

```julia
B = zeros(ComplexF64,3,3)
B[1,2] = 4 + 2im
```
とすればよいです。ここで、```zeros(ComplexF64,3,3)```の```ComplexF64```は倍精度複素数型を意味しています。このように、行列を初期化（zerosで０行列を作る）ときには、入れる行列要素の種類（型）が合っていなければなりません。

なお、初期化するにはもう一つ方法がありまして、

```julia
B = Array{ComplexF64}(undef,3,3)
```
とすると、行列要素の型は倍精度複素数```ComplexF64```だけれども行列要素が何も定義されていない行列、を定義することができます。


## 3.3. 数式をコードにしてみよう
物理で使うような数式をコードにしてみましょう。
紹介する具体例を通じて、Juliaでどのようにコードを書けばよいかを紹介します。

### 3.3.1. 関数の振る舞いをみる：forループとplot
ある関数：
$$
f(x) = \cos(x) e^{-x}
$$
という関数の振る舞いが知りたいとします。
一番簡単な方法は、xに様々な値を入れて値を見てみることでしょう。
例えば、x=0からx=1まで、n点でのf(x)の値を見ることにします。
Juliaでは様々な書き方ができますので、順番にみていくことにします。

#### 3.3.1.1. forループ1
一番素朴な方法は、x=0から1まで少しずつ値を増やして様子を表示することでしょう。つまり、１番目はx=0で、2番めは0+1/(n-1)、i番め0+(i-1)/(n-1)と少しずつxを増やしていって値を計算してみます。
このような繰り返しをする構文として、for文があります。
例えば、

```julia
for i=1:10
    println(i)
end
```
とすると、1から10までが表示されます。2ずつ増やしたい場合には、

```julia
for i=1:2:10
    println(i)
end
```
ですし、負にも動かすことができて、10から1ずつ減らしたければ、

```julia
for i=10:-1:1
    println(i)
end
```
となります。このように、forループを使えば繰り返しを実行できます。
そこで、「１番目はx=0で、2番めは0+1/(n-1)、i番め0+(i-1)/(n-1)と少しずつxを増やしていって値を計算」するには、

```julia
f(x) = cos(x)*exp(-x)
n=10
for i=1:n
    x = (i-1)/(n-1)
    println(f(x))
end
```
とすればよいです。上のコードではf(x)だけ表示していますが、その時のxの値などを表示したければ、

```julia
f(x) = cos(x)*exp(-x)
n=10
for i=1:n
    x = (i-1)/(n-1)
    println("$x $(f(x))")
end
```
とします。ここで、printlnの別の文法が登場しました。""で囲まれたものは文字列です。文字列の中に変数を入れるためには、```$(a)```などとします。なお、一文字であれば```$a```でも構いません。これを使って```println("$(a) $(b)")```とすると、変数aや変数bを表示することができます。この辺りは後述します。


#### 3.3.1.2. forループ2
x=0から1まで少しずつ増やす方法はFortranなどの古くからあるプログラミング言語ではよく使われていた方法です。Juliaでは、上のようにxの増分をはっきり書かなくてもよい方法があります。

```julia
f(x) = cos(x)*exp(-x)
n = 10
xs = range(0, 1, length=n)
for x in xs    
    println("$x $(f(x))")
end
```
このコードでは、「１番目はx=0で、2番めは0+1/(n-1)、i番め0+(i-1)/(n-1)と少しずつxを増やしていった値」を```range```であらかじめ求めてしまっています。```rand(start,stop,length=n)```とすると、最初がstart、終わりがstop、長さがnの塊を作ってくれます。
そして、for文では```for i=1:n```の代わりに```for x in xs```という表記を使っています。これは、```xs```の中身を```x```として順番に取り出す、という意味です。


#### 3.3.1.3. ベクトルや行列の要素ごと計算
上の二つでは、for文を使ってそれぞれのxでのf(x)を求めていましたが、Juliaではこれをfor文を使わずにまとめて計算する方法もあります。それは、要素ごと計算です。

例えば、

```julia
f(x) = cos(x)*exp(-x)
n = 10
xs = range(0, 1, length=n)
f.(xs)
```
とすると、xsの中身のそれぞれに対してf(x)を計算します。
上と同様に表示させたければ、

```julia
f(x) = cos(x)*exp(-x)
n = 10
xs = range(0, 1, length=n)
fs = f.(xs)
for i=1:n
    println("$(xs[i]) $(fs[i])")
end
```
とします。ここでは、for文を使って、iを1からnまで回して、xsとfsのそれぞれの要素を```xs[i]```、```fs[i]```として取り出しています。

ここで出てきたのは、ドット```.```です。ドットを使うと、行列やベクトルの要素のそれぞれに計算をすることができます。

例えば、
```julia
A = [1 2 3
4 5 6
7 8 9 ]
B = A .+ 3
```
とすれば、行列Bは行列Aの各要素に3を足したものになります。数学では、B = A+3と書くと自動的にAの各要素に3を足すと理解されますが、Juliaの場合には明示的に```.+```とすることで要素ごとに足すことを指定します。

#### 3.3.1.4. プロット
関数の振る舞いを見るにはプロットすることも重要です。
Juliaにはプロットする関数もあります。
Juliaでは、非常に多彩な「パッケージ」と呼ばれるものがあり、それを追加することで新しい機能を使うことができます。プロットの場合にはPlots.jlというパッケージが有名です。
これを使うには、```]```キーを押して「パッケージモード」：

```julia
(v1.1) pkg>
```
にします。そして、

```julia
add Plots
```
と入れることで、プロットのパッケージを追加することができます。パッケージモードを終了するには、delキーを押してください。なお、一度入れたパッケージは毎回入れ直す必要はありません。

インストールしたPlots.jlを使うには、パッケージモードを終了した後に、
```julia
using Plots
```
としてください。これでプロット関連の関数が使えるようになります。
上の関数をプロットしたい場合には、

```julia
plot(xs,fs)
```
とすれば、グラフが表示されます。

### 3.3.2. 級数の和の計算：sumとリスト内包表記、If文、while文、引数の型、多重ディスパッチ
次に、
$$
f(x) = \sum_{n=0}^{\infty} \frac{1}{n!} x^n
$$
を計算してみましょう。この級数は指数関数exp(x)のテイラー展開ですね。
計算機では無限の和を取れないので、nの最大値を指定する必要があります。
ですので、nの最大値nmaxをパラメータとしましょう。

#### 3.3.2.1. シンプルな場合:リスト内包表記
シンプルな方法として

```julia
f(x,nmax) = sum([x^n/factorial(n) for n=0:nmax])
f(2,10)
```
を紹介します。まず、```[2*n for n=0:10]```のような構文をリスト内包表記と呼びます。これは、for文にある変数（ここではn）を回しながら配列を作ります。例えば、上のコードであれば、nは0からnmaxまで動きますので、要素数がnmax+1の配列ができます。そして、```sum```という関数は、配列の中身を足す関数です。つまり、作った配列の中身を合計しているので、これは数式でいう所のsumになっています。なお、```factorial(n)```はnの階乗を計算する関数です。

#### 3.3.2.2. forループによる足し算



次に、forループで足してみます。
この場合、fを一行で書くよりもfunctionで定義した方がみやすいです。ですので、

```julia
function f(x,nmax)
    fsum = 0
    for n=0:nmax
        fsum += x^n/factorial(n)
    end
    return fsum
end
f(2,10)
```


としてみましょう。このコードでは、まずfsumを0に初期化して、そのあとはforループでひたすら項を足しています。そして、functionの結果として、fsumを返すようにしています。ここで```+=```という新しい文法が登場しました。これは、「左辺にある変数に右辺にある値を足す」、という意味です。同様に、```-=```や```*=```、```/=```などもあります。
さて、functionの最後に```return```という文があります。これは、結果を返す変数を指定するものです。```return a```とすると、変数aが結果として返ります。ここは複数にすることができて、その場合には```return a,b```などとなります。数学での関数では通常一つしか結果が出てきませんが、プログラムとしてはそこを一つと制限する必要はありませんので、複数結果を返すことができます。
プログラムで数値計算する場合には多くの場合関数が一行で書けるとは限りませんので、このようにで囲って```function```と```end```で関数を定義します。

#### 3.3.2.3. 精度コントロール：If文とwhile文の紹介
次に、nmaxをどこまで取るか、という問題を考えます。
計算したい和は本来無限まで続くのですが、計算機では無限に和は取れません。ですので、なるべく大きなnmaxを取る必要があります。しかし、どこまでとれば良いでしょうか？
ここでは、If文を使って、設定した精度に到達するまで和を取るような関数を作ることにします。

まず、If文ですが、Juliaでは

```julia
a = 3
if a > 4
    println("a>4")
elseif a == 4
    println("a = 4")
else
    println("a < 4")
end
```
のようにします。「もしa>4ならば」は```if a >4```です。また、「あるいはもしa=4ならば」、は```elseif a ==4```です。それ以外は```else```の後に書きます。このifの後に書かれているものを条件式と呼びます。
条件式は真か偽になるものを入れることができます。例えば、

```julia
if true
    println("真")
end
```
のように```true```そのものを入れることができます。a=3の時、```a > 4```は偽ですので、

```julia
a = 3
a > 4
```
とすると、```false```が返ります。これを変数として使うことものできて、

```julia
c = a >4
if c
    println("真")
else
    println("偽")
end
```
ともできます。ここでのcの型はbool型と呼ばれます。trueかfalseが入る型、という意味です。

さて、このif文を使って、精度を決めた数式を関数にしてみましょう。

```julia
function f(x,eps)
    fsum = 0
    fsumold = 0
    hi = 1
    n = 0
    while hi > eps    
        fsum += x^n/factorial(n)
        hi = abs(fsum-fsumold)/abs(fsum)
        fsumold = fsum
        n += 1
    end
    return fsum,n
end
fapp,n = f(2,1e-4)
println(fapp-exp(2)," $n")
```
このコードでは、forループの代わりにwhileループを使っています。
whileループでは、```while c``` のように書き、「cが満たされている間ずっと繰り返す」という意味です。今回は、```abs(fsum-fsumold)/abs(fsum)```で前回までの和との差を計算しており、その差がepsよりも大きい間はnを増やしてループを続けています。
また、```return fsum,n```となっていますので、結果は二つの変数fsum,nが返ってきます。ですので、```fapp,n = f(2,1e-4)```とすると、一個目の結果をfappに、二個目の結果をnに入れています。
epsの値を色々変化させて、指定された精度に達するのにどのくらいのnmaxが必要かを見てみると良いかもしれません。

#### 3.3.2.4. 解析接続：引数の型の自由
さて、ここまで関数f(x)のxには実数を入れてきました。しかし、このxに複素数を入れても問題ありません。つまり、解析接続ですね。xに純虚数を入れると、この式は指数関数exp(ix)の定義になりますので、cos(x)+i sin(x)となります。
Fortranやc言語の場合には、関数の引数（ここではx）の型を指定しなければなりません。Juliaでは、xにどんな型が来ても計算可能であれば計算できます。
例えば、

```julia
fapp,n = f(0.1im,1e-4)
println(fapp-exp(0.1im)," $n")
```
とすれば、複素数のxに対して計算ができます。

#### 3.3.2.5. 同じ名前の関数の定義：多重ディスパッチ
この説で、関数として、nmaxを指定するものと、epsを指定するものを作りました。この両方とも使いたい場合があると思います。もともと計算したい関数は同じですので、同じ名前のfunctionとしたいです。
以下の二つの関数を定義してみましょう。

```julia
function f(x,nmax::Int)
    fsum = 0
    for n=0:nmax
        fsum += x^n/factorial(n)
    end
    return fsum
end

function f(x,eps::Real)
    fsum = 0
    fsumold = 0
    hi = 1
    n = 0
    while hi > eps    
        fsum += x^n/factorial(n)
        hi = abs(fsum-fsumold)/abs(fsum)
        fsumold = fsum
        n += 1
    end
    return fsum,n
end

println(f(2,10))
println(f(2,1e-5))
```
一つ目のfunctionでは、```nmax:::Int```としています。これは、引数のnmaxはIntすなわち整数でなければならない、という意味です。二つ目のfuncitonでは、```eps::Real```となっており、引数のepsはRealすなわち実数でなければならない、という意味です。このように、Juliaでは、「同じfunction名を使って、引数の型に応じて呼ぶものを変える」ことができます。これを<u>多重ディスパッチ</u>と言います。この時の関数の引数の数も変えることができます。
ですので、

```julia
function f(x;eps=1e-5)
    fsum = 0
    fsumold = 0
    hi = 1
    n = 0
    while hi > eps    
        fsum += x^n/factorial(n)
        hi = abs(fsum-fsumold)/abs(fsum)
        fsumold = fsum
        n += 1
    end
    return fsum,n
end
println(f(2))
println(f(2,eps=1e-10))
```
ということもできます。ここで、```f(x;eps=1e-5)```としていますが、この```;```以降のepsは、キーワード引数と呼ばれるもので、```f(2)```のように省略することができます。もし変えたい場合には、```f(2,eps=1e-10)```などのようにします。


### 3.3.3. 特殊関数
次に、物理でよく使われる特殊関数を扱ってみましょう。
ということで、第一種変形ベッセル関数を使った式
$$
g(x) = \sum_{n=0}^{10} (I_{n}(x) + n^2 I_{2n}(x))
$$
を計算してみます。ここで、$I_{n}(x)$は次数がnの第一種変形ベッセル関数です。
特殊関数を使うためには、SpecialFunctions.jlを使います。
まず、]を押してパッケージモードにしてから、

```julia
add SpecialFunctions
```
をしてパッケージをインストールします。その後、delキーを押してパッケージモードを終了します。以後は、```using SpecialFunctions```とすることで使うことができます。
上の関数を計算するコードは

```julia
using SpecialFunctions
function g(x)
    gsum = 0
    for n=0:10
        gsum += besseli(n,x)+n^2*besseli(2n,x)
    end
    return gsum
end
```
です。これをプロットするためには、

```julia
using Plots
xs = range(0, 1, length=100)
temp = g.(xs)
plot(xs,temp)
```
とします。
なお、SpecialFunctionsの中にどのような特殊関数があるかは、
https://github.com/JuliaMath/SpecialFunctions.jl/blob/master/docs/src/index.md
をみるとわかります。

### 3.3.4. 1次元数値積分
物理では積分することは非常に多いです。
ここでは、数値積分をやってみましょう。積分する関数は、一次元の波数空間における積分：

$$
I = \frac{1}{2π} \int_{-\pi}^{\pi} dk f(k)
$$
とします。
関数$f(k)$は試しに

$$
f(k) = \sin (k) + k^2
$$
としてみます。積分は手で
できて、

$$
I = \frac{1}{2\pi}\frac{2}{3}(\pi)^3 = 3.2898681336964524
$$
となります。

#### 3.3.4.1. 台形公式による積分
まず、一番基本的な数値積分である、台形公式による積分をやってみましょう。
積分を$N$分割すると、

$$
\frac{1}{2π}  \int_{-\pi}^{\pi} dk \sim \frac{1}{2π}  \sum_i f(k_i) \frac{2\pi}{N} = \frac{1}{N} \sum_i f(k_i) 
$$

となります。ここで、台形公式の最初の点と最後の点が同一の点であることを利用し、ただの和にすることができることを用いました。
Juliaではfunctionを引数にすることができます。
したがって、

```julia
function daikei(f,N)
    dk = 2π/(N-1)
    fsum = 0
    for i=1:N
        k = (i-1)*dk - π
        fsum += f(k)
    end
    fsum /= N
    return fsum
end

f(x) = sin(x) + x^2
N = 400
fsum = daikei(f,N)
exact = ((π)^3/3 -(-π)^3/3)/(2π)
println("daikei $fsum, exact $exact")
```
で台形公式による数値積分ができます。

#### 3.3.4.2. パッケージを使った数値積分
次に、Juliaのパッケージを使ってみましょう。
１次元の数値積分パッケージはQuadGK.jl
https://github.com/JuliaMath/QuadGK.jl
があります。
使うためには、]を押してパッケージモードにしてから、

```julia
add QuadGK
```
をしてパッケージをインストールします。
QuadGKでは、```quadgk(f,a,b)```で、関数f(x)とaからbの積分区間で積分ができます。

```julia
using QuadGK
f(x) = sin(x) + x^2
fsum2 = quadgk(f,-π,π)[1]/(2π)
exact = ((π)^3/3 -(-π)^3/3)/(2π)
println("quadgk $fsum2, exact $exact")
```
```quadgk```のアウトプットは```(I,E)```という形で二つでてきます。ここで、丸括弧はタプル、と呼ばれるものです。配列は[]でしたが、タプルは()です。配列は要素の中身を変更できますが、タプルは変更できない、という違いがあります。
アウトプットのうちIは積分の値、Eは誤差です。
この手法の方が、台形公式よりもはるかに精度が高いことが見てとれると思います。



以下執筆予定