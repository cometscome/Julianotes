物理で使う数値計算入門：Julia言語による簡単数値計算
=============

<div style="text-align: right;">
令和元年5月1日
</div>
<div style="text-align: right;">
永井佑紀
</div>

目次
=
<!-- TOC -->

- [1. はじめに：このノートの目的](#1-はじめにこのノートの目的)
    - [1.1. Juliaの利点](#11-juliaの利点)
    - [1.2. 具体的な利点](#12-具体的な利点)
- [2. Juliaのインストール](#2-juliaのインストール)
    - [2.1. 二種類の実行方法](#21-二種類の実行方法)
    - [2.2. バージョン](#22-バージョン)
    - [2.3. Macの場合](#23-macの場合)
    - [2.4. Linuxの場合](#24-linuxの場合)
    - [2.5. Windowsの場合](#25-windowsの場合)
- [3. 基本編](#3-基本編)
    - [3.1. いじってみよう](#31-いじってみよう)
        - [3.1.1. 足し算、引き算](#311-足し算引き算)
        - [3.1.2. かけ算と割り算](#312-かけ算と割り算)
        - [3.1.3. あまり](#313-あまり)
        - [3.1.4. べき乗、指数関数、対数関数](#314-べき乗指数関数対数関数)
        - [3.1.5. 三角関数](#315-三角関数)
        - [3.1.6. 円周率](#316-円周率)
        - [3.1.7. 虚数](#317-虚数)
        - [3.1.8. 関数](#318-関数)
    - [3.2. 変数](#32-変数)
        - [3.2.1. 整数、実数、複素数](#321-整数実数複素数)
        - [3.2.2. 文字列](#322-文字列)
        - [3.2.3. ベクトルと行列](#323-ベクトルと行列)
    - [3.3. 数式をコードにしてみよう](#33-数式をコードにしてみよう)
        - [3.3.1. 関数の振る舞いをみる：forループとplot](#331-関数の振る舞いをみるforループとplot)
            - [3.3.1.1. forループ1](#3311-forループ1)
            - [3.3.1.2. forループ2](#3312-forループ2)
            - [3.3.1.3. ベクトルや行列の要素ごと計算](#3313-ベクトルや行列の要素ごと計算)
            - [3.3.1.4. プロット](#3314-プロット)
        - [3.3.2. 級数の和の計算：sumとリスト内包表記、If文](#332-級数の和の計算sumとリスト内包表記if文)
            - [3.3.2.1. シンプルな場合:リスト内包表記](#3321-シンプルな場合リスト内包表記)
            - [3.3.2.2. forループによる足し算](#3322-forループによる足し算)
            - [3.3.2.3. 精度コントロール：If文の紹介](#3323-精度コントロールif文の紹介)

<!-- /TOC -->

# 1. はじめに：このノートの目的
初めて数値計算をする人がJuliaを使って簡単にコードを書いて計算できるように、という意図で書いています。特に、物理で使うことの多い計算を中心にまとめています。

## 1.1. Juliaの利点

Juliaは2018年にバージョン1となったばかりの非常に新しいプログラミング言語ですので、様々なプログラミング言語の良いところを取り入れており、非常に<u>書きやすく</u>かつ<u>高速</u>です。また、FortranやCと違い、コンパイルが必要ありません。ですので、Pythonのようなスクリプト言語のように使うことができます。Pythonは現在非常に人気のある言語ですので、書籍も豊富でWebでの文献も多く、最初のプログラミング言語として勧められることも多いと思います。しかし、Pythonを数値計算で使う場合、特別な処置をしないと非常に遅いという問題があります。
そのため、Pythonで数値計算をすると遅いために、FortranやCを数値計算のための言語として勧められることも多いと思います。
Juliaは、「Pythonのように書きやすく」「FortranやCど同程度に速い」言語となるように設計されているために、数値計算を学ぶ際の最適な言語の一つになっています。

つまり、Juliaは

- FortranやCと同程度に高速
- Pythonと同じくらい書きやすく
- 数式を扱うようにコードを書くことができる

という言語です。

## 1.2. 具体的な利点
コードを見ればわかりますが、Julia の場合、Fortran や C で必要であったたくさんの「おまじない」や Lapackのインストールや呼び出しなどの煩雑なことを一切する必要がありません。Pythonでも似たような形でシンプルにコードが書けますが、Pythonは For ループが遅いという数値計算として使うには問題となる点(工夫すれば速くなりますが Python ならではのこの工夫を習得するのに時間がかかります）゙があります。この問題点のせいで、教科書に書いてあるようなアルゴリズムを Python にそのまま移植するととんでもなく遅くなってしまうことがあります。Python はあらかじめわかっているアルゴリズムを呼び出すことにかけてはそのライブラリの豊富さとコミュニティの広さで圧倒的ですが、新しいアルゴリズムを書いたりする場合には、最適ではないと思います。その点、Julia はアルゴリズムをそのままコードにするだけで速いです。これは、「物理以外の余計なことを考えずに物理の結果が知りたい」という、物理をやる人間にとって重要な欲求を満たす可能性のある言語となっている、ということですので、有望だと思います。


# 2. Juliaのインストール

## 2.1. 二種類の実行方法

Juliaを使うには、二つの方法があります。
1. 対話的実行環境　REPL(read-eval-print loop)
2. 通常の実行方法

1は、普通のアプリケーションのようにJuliaを起動して、その中でコードを書いたり計算をしたりプロットしたりするものです。簡単な計算を気軽に試すことができます。

2は、通常の実行方法で、ファイルにプログラムコードを```test.jl```みたいな形で保存してから、

```
julia test.jl
```
で実行する方法です。

このノートでは、最初は簡単なので1.のREPLを使います。少し複雑になってきた場合には、ファイルにコードを保存して、2.で実行することにします。




## 2.2. バージョン
このノートでのJuliaのバージョンは、1.1.0とします。

## 2.3. Macの場合

https://julialang.org/downloads/
から```macOS 10.8+ Package (.dmg)```をダウンロードして、他のアプリケーションと同様にインストールします。インストールしたあとは、アプリケーションにJulia 1.1がありますので、それをダブルクリックするとターミナルが起動して使えるようになります。

## 2.4. Linuxの場合
Linuxの場合には、

```
wget https://julialang-s3.julialang.org/bin/linux/x64/1.1/julia-1.1.0-linux-x86_64.tar.gz
tar -xvf julia-1.1.0-linux-x86_64.tar.gz
echo 'export PATH="$PATH:$HOME/julia-1.1.0/bin"' >> ~/.bashrc
source ~/.bashrc
```
でインストールができますので、あとは

```
julia
```
で起動することができます。

## 2.5. Windowsの場合
Windows版のJuliaをインストールすれば使用できます。あるいは、Windows Subsystem for Linuxを使ってUbuntuを入れることで上のLinuxと同じようにインストールすることもできます。


# 3. 基本編
この章では、REPLの上でJuliaを使ってみましょう。
## 3.1. いじってみよう
まずはじめに、プログラミング言語での定番、Hello worldですが、これは、

```julia
println("Hello World!")
```
で出力されます。
ここで、```println```は最後に改行あり、```print```は改行なしです。
関数の説明がみたい時には、?を押すとHelpモードに入りますので、そこで関数名を入れます。

なお、REPLを終了するには、

```julia
exit()
```
とします。

### 3.1.1. 足し算、引き算
足し算は、

```julia
1+2
```
でできますし、引き算は

```julia
2-5
```
でできます。

### 3.1.2. かけ算と割り算
かけ算は、```*```の記号で、

```julia
2*3
```
となりますし、割り算の記号は```/```で、

```julia
4/2
```
でできます。
割り算については注意があります。上の計算を行うと、

```
2.0
```
となりました。2と2.0の違いは、整数と実数の違いです。
もちろん、計算機では無限の桁の実数を扱うことはできませんから、この実数は桁があります。それについては後述します。
もし、割った結果を整数で欲しい場合には、

```julia
div(4,2)
```
とすると、答えとして```2```が返ってきます。


### 3.1.3. あまり
割り算のあまりを計算することもできます。その場合には、```%```を使います。

```julia
5%2
```
とすると、5わる2のあまりである1が出ます。

### 3.1.4. べき乗、指数関数、対数関数
べき乗は```^```でできますので、

```julia
3^7
```
となります。
指数関数は```exp```で、

```julia
exp(3)
```
でできますし、自然対数は```log```で

```julia
log(2)
```
となります。対数の底が2と10の時はそれぞれ```log2```と```log10```が使えて、

```julia
log2(4)
```
や
```julia
log10(100)
```
が使えます。任意の底の場合には、nを底、xを値として、```log(n,x)```で使えまして、

```julia
log(3,9)
```
となります。

### 3.1.5. 三角関数
三角関数も普通に使うことができます。
例えば、

```julia
sin(0.1)+2*cos(0.3)
```
などができます。もちろん、tanhなども使えます。

### 3.1.6. 円周率
円周率はデフォルトで入っています。日本語の漢字変換で「ぱい」としてπを入力するか、REPL上で```\pi```としてからタブキーを押すことでπを使うことができますので、

```julia
cos(3π)
```
というような形で書くことができます。
ここで、```3π```と書きましたが、かけ算の記号```*```を使って```3*π```と書くこともできます。後述しますが、数字と記号の積の場合には、記号```*```を省略して書くことできます。
これにより、より数式に近い見た目になります。

### 3.1.7. 虚数
虚数も複素数も簡単に扱うことができます。
虚数単位は```im```です。ですので、

```julia
4 + 5im
```
などと書きます。なお、円周率と同様に、```5*im```は```5im```と記号```*```を省略できます。
三角関数と組み合わせれば、

```julia
exp(im*π)
```
とすることもできます。
なお、この計算を行うと、結果は

```julia
-1.0 + 1.2246467991473532e-16im
```
のような形で表示されていると思います。この値は厳密には-1になるべきですが、すごく小さい虚数が入っています。これは、計算機の中の実数が本当の実数ではないことと関連していまして、ここで使われている数の桁数が16桁（倍精度実数と呼びます）であることを意味しています。
なお、より精度の高い計算をするための方法も実装されていまして、

```julia
exp(im*BigFloat(π))
```
と```BigFloat```を使うと、

```julia
-1.0 + 1.096917440979352076742130626395698021050758236508687951179005716992142688513354e-77im
```
とより精度の高い計算をすることができます。

### 3.1.8. 関数
次に、自分で定義した関数を使うことを考えます。
例えば、

$$
f(x)= \cos(x)+2\sin(x^2)
$$
という関数であれば、

```julia
f(x) = cos(x) +2*sin(x^2)
```
とそのまま関数を定義することができます。そして、例えばx=4での値などが知りたい場合には、

```julia
f(4)
```
とすれば出ます。

この```f(x)```をfunction、つまり関数と呼びます。上では一行で関数を定義しましたが、もう少し複雑な場合には、

```julia
function f(x)
    cos(x) +2*sin(x^2)
end
```
とすることができます。この形の関数については後述します。

ここまでで、電卓的な使い方を一通り見ることができました。

## 3.2. 変数
次は、変数を紹介します。
先ほどの関数
$$
f(x)= \cos(x)+2\sin(x^2)
$$
を
$$
f(x)= \cos(x)+a\sin(x^2)
$$
にしてみましょう。もし、この関数f(x)がaに依存しているならば、
$$
f(x,a)= \cos(x)+a\sin(x^2)
$$
と書くことも可能です。
このコードは、

```julia
f(x,a) = cos(x) +a*sin(x^2)
```
とそのままに書くことができます。ここで、あらかじめaに値を入れておけば、

```julia
a = 3
f(4,a)
```
などと書けます。このaを「変数」と呼びます。

変数には様々なものを入れることができます。
### 3.2.1. 整数、実数、複素数
整数、実数、複素数であれば、

```julia
a = 3
b = 2.3
c = 4+5im
```
のようになります。これらはそれぞれ演算ができて、

```julia
a*b + c/a
```
は複素数が出てきます。
また、変数の記号として、アルファベット以外も使うことができます。
例えば、

```julia
H = 1.2
β = 2
Z = exp(-β*H)
```
でのβのようなギリシャ文字や、

```julia
りんご = 30
みかん = 20
りんご*2 + みかん*3
```
のような日本語も使用可能です。このように変数に様々な文字が使えるので、物理に出てくる数式をほとんどそのままコードとして書くことができます。

### 3.2.2. 文字列
変数には文字を入れることができます。
例えば、

```julia
a = "Warrior"
b = "Magic"
c = b*a
println(c)
```
とすると、出力として、```MagicWarrior```が出てきます。
注意点としては、文字列と文字列を合体させるときには、積の記号と同じ```*```を使うことです。これは、文字列の合体は非可換な積であるというコンセプトのもとに設定されているようです。なお、Pythonでは```+```を使います。


### 3.2.3. ベクトルと行列
物理の数値計算をするのであれば避けて通れないのは、ベクトルと行列です。ですので、変数にベクトルや行列を入れることができます。
Juliaでは、ベクトルは

```julia
a = [1,2,3,4]
```
と書くことができます。そして、行列は

```julia
B = [1 2 3 4
5 6 7 8]
```
と書くことができます。ここでBは2x4行列です。行列の要素同士はスペースで区切ります。また、

```julia
B = [1 2 3 4;5 6 7 8 ]
```
のように、改行の代わりに```;```を使うこともできます。

2x4行列と4成分ベクトルの積は

```julia
B*a
```
と通常の積の記号```*```でできます。
n成分ベクトルはnx1行列とみなすことができるので、

```julia
c = [1
2
3
4]
```
と書くこともできます。

サイズの大きい行列を定義するのにいちいち全部行列要素を書くのは大変です。ですので、まとめて扱う方法があります。
例えば、3x3の零行列は

```julia
B = zeros(3,3)
```
と定義することができます。もし、ほとんどがゼロの行列で一部だけ何か値がある場合には、

```julia
B[1,2] = 4
println(B)
```
とします。ここで、```B[1,2]```は、1行2列目の行列要素です。
Juliaでは、行列の要素は1から数えます。3x3行列であれば、1,2,3、となります。Pythonは0から数え0,1,2ですので、違いに気をつけてください。

さて、零行列Bを定義した後に、その一部の行列要素が複素数である場合を考えます。その場合、

```julia
B = zeros(3,3)
B[1,2] = 4 + 2im
```
はエラーが出てしまいます。何が問題なのでしょうか？

問題は、

```julia
B
```
としてみるとわかります。
これを打ってみると、

```julia
3×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0
```
となります。この```Array```が、Bが行列であることを意味しています。Arrayは```A[1,2,3]```のような3つ以上の足をつけることができますので、配列、と呼ばれています。
Bは```3×3 Array{Float64,2}```のようです。
ここで、```3x3```は3x3行列であることを意味しています。次の```Array{Float64,2}```は、行列要素の中身が```Float64```であり、足が２つある、ということを意味しています。```Float64```とは、倍精度実数であり、変数の種類のことをさします。
例えば、

```julia
 C = [1 2
       3 4]
```
とすると、

```julia
2×2 Array{Int64,2}:
 1  2
 3  4
```
となりまして、```Array{Int64,2}```は、行列要素の中身が```Int64```であることを意味しています。つまり、行列要素が整数、ということを言っています。
このような変数の種類のことを「型」と言います。
先ほどの行列Bは行列要素がFloat64でなければならない、ということです。ただし、
```julia
B = zeros(3,3)
B[1,2] = 4 
```
は可能です。4は整数ですが、整数から実数へは変換することができます。4が4.0になるわけです。しかし、```4+2im```のような複素数の場合、これは実数に変換できません。そのため、エラーが出ました。
これを解決するためには、

```julia
B = zeros(ComplexF64,3,3)
B[1,2] = 4 + 2im
```
とすればよいです。ここで、```zeros(ComplexF64,3,3)```の```ComplexF64```は倍精度複素数型を意味しています。このように、行列を初期化（zerosで０行列を作る）ときには、入れる行列要素の種類（型）が合っていなければなりません。

なお、初期化するにはもう一つ方法がありまして、

```julia
B = Array{ComplexF64}(undef,3,3)
```
とすると、行列要素の型は倍精度複素数```ComplexF64```だけれども行列要素が何も定義されていない行列、を定義することができます。


## 3.3. 数式をコードにしてみよう
物理で使うような数式をコードにしてみましょう。
紹介する具体例を通じて、Juliaでどのようにコードを書けばよいかを紹介します。

### 3.3.1. 関数の振る舞いをみる：forループとplot
ある関数：
$$
f(x) = \cos(x) e^{-x}
$$
という関数の振る舞いが知りたいとします。
一番簡単な方法は、xに様々な値を入れて値を見てみることでしょう。
例えば、x=0からx=1まで、n点でのf(x)の値を見ることにします。
Juliaでは様々な書き方ができますので、順番にみていくことにします。

#### 3.3.1.1. forループ1
一番素朴な方法は、x=0から1まで少しずつ値を増やして様子を表示することでしょう。つまり、１番目はx=0で、2番めは0+1/(n-1)、i番め0+(i-1)/(n-1)と少しずつxを増やしていって値を計算してみます。
このような繰り返しをする構文として、for文があります。
例えば、

```julia
for i=1:10
    println(i)
end
```
とすると、1から10までが表示されます。2ずつ増やしたい場合には、

```julia
for i=1:2:10
    println(i)
end
```
ですし、負にも動かすことができて、10から1ずつ減らしたければ、

```julia
for i=10:-1:1
    println(i)
end
```
となります。このように、forループを使えば繰り返しを実行できます。
そこで、「１番目はx=0で、2番めは0+1/(n-1)、i番め0+(i-1)/(n-1)と少しずつxを増やしていって値を計算」するには、

```julia
f(x) = cos(x)*exp(-x)
n=10
for i=1:n
    x = (i-1)/(n-1)
    println(f(x))
end
```
とすればよいです。上のコードではf(x)だけ表示していますが、その時のxの値などを表示したければ、

```julia
f(x) = cos(x)*exp(-x)
n=10
for i=1:n
    x = (i-1)/(n-1)
    println("$x $(f(x))")
end
```
とします。ここで、printlnの別の文法が登場しました。""で囲まれたものは文字列です。文字列の中に変数を入れるためには、```$(a)```などとします。なお、一文字であれば```$a```でも構いません。これを使って```println("$(a) $(b)")```とすると、変数aや変数bを表示することができます。この辺りは後述します。


#### 3.3.1.2. forループ2
x=0から1まで少しずつ増やす方法はFortranなどの古くからあるプログラミング言語ではよく使われていた方法です。Juliaでは、上のようにxの増分をはっきり書かなくてもよい方法があります。

```julia
f(x) = cos(x)*exp(-x)
n = 10
xs = range(0, 1, length=n)
for x in xs    
    println("$x $(f(x))")
end
```
このコードでは、「１番目はx=0で、2番めは0+1/(n-1)、i番め0+(i-1)/(n-1)と少しずつxを増やしていった値」を```range```であらかじめ求めてしまっています。```rand(start,stop,length=n)```とすると、最初がstart、終わりがstop、長さがnの塊を作ってくれます。
そして、for文では```for i=1:n```の代わりに```for x in xs```という表記を使っています。これは、```xs```の中身を```x```として順番に取り出す、という意味です。


#### 3.3.1.3. ベクトルや行列の要素ごと計算
上の二つでは、for文を使ってそれぞれのxでのf(x)を求めていましたが、Juliaではこれをfor文を使わずにまとめて計算する方法もあります。それは、要素ごと計算です。

例えば、

```julia
f(x) = cos(x)*exp(-x)
n = 10
xs = range(0, 1, length=n)
f.(xs)
```
とすると、xsの中身のそれぞれに対してf(x)を計算します。
上と同様に表示させたければ、

```julia
f(x) = cos(x)*exp(-x)
n = 10
xs = range(0, 1, length=n)
fs = f.(xs)
for i=1:n
    println("$(xs[i]) $(fs[i])")
end
```
とします。ここでは、for文を使って、iを1からnまで回して、xsとfsのそれぞれの要素を```xs[i]```、```fs[i]```として取り出しています。

ここで出てきたのは、ドット```.```です。ドットを使うと、行列やベクトルの要素のそれぞれに計算をすることができます。

例えば、
```julia
A = [1 2 3
4 5 6
7 8 9 ]
B = A .+ 3
```
とすれば、行列Bは行列Aの各要素に3を足したものになります。数学では、B = A+3と書くと自動的にAの各要素に3を足すと理解されますが、Juliaの場合には明示的に```.+```とすることで要素ごとに足すことを指定します。

#### 3.3.1.4. プロット
関数の振る舞いを見るにはプロットすることも重要です。
Juliaにはプロットする関数もあります。
Juliaでは、非常に多彩な「パッケージ」と呼ばれるものがあり、それを追加することで新しい機能を使うことができます。プロットの場合にはPlots.jlというパッケージが有名です。
これを使うには、```]```キーを押して「パッケージモード」：

```julia
(v1.1) pkg>
```
にします。そして、

```julia
add Plots
```
と入れることで、プロットのパッケージを追加することができます。パッケージモードを終了するには、delキーを押してください。なお、一度入れたパッケージは毎回入れ直す必要はありません。

インストールしたPlots.jlを使うには、パッケージモードを終了した後に、
```julia
using Plots
```
としてください。これでプロット関連の関数が使えるようになります。
上の関数をプロットしたい場合には、

```julia
plot(xs,fs)
```
とすれば、グラフが表示されます。

### 3.3.2. 級数の和の計算：sumとリスト内包表記、If文
次に、
$$
f(x) = \sum_{n=0}^{\infty} \frac{1}{n!} x^n
$$
を計算してみましょう。この級数は指数関数exp(x)のテイラー展開ですね。
計算機では無限の和を取れないので、nの最大値を指定する必要があります。
ですので、nの最大値nmaxをパラメータとしましょう。

#### 3.3.2.1. シンプルな場合:リスト内包表記
シンプルな方法として

```julia
f(x,nmax) = sum([x^n/factorial(n) for n=0:nmax])
f(2,10)
```
を紹介します。まず、```[2*n for n=0:10]```のような構文をリスト内包表記と呼びます。これは、for文にある変数（ここではn）を回しながら配列を作ります。例えば、上のコードであれば、nは0からnmaxまで動きますので、要素数がnmax+1の配列ができます。そして、```sum```という関数は、配列の中身を足す関数です。つまり、作った配列の中身を合計しているので、これは数式でいう所のsumになっています。なお、```factorial(n)```はnの階乗を計算する関数です。

#### 3.3.2.2. forループによる足し算



次に、forループで足してみます。
この場合、fを一行で書くよりもfunctionで定義した方がみやすいです。ですので、

```julia
function f(x,nmax)
    fsum = 0
    for n=0:nmax
        fsum += x^n/factorial(n)
    end
    return fsum
end
f(2,10)
```


としてみましょう。このコードでは、まずfsumを0に初期化して、そのあとはforループでひたすら項を足しています。そして、functionの結果として、fsumを返すようにしています。ここで```+=```という新しい文法が登場しました。これは、「左辺にある変数に右辺にある値を足す」、という意味です。同様に、```-=```や```*=```、```/=```などもあります。
さて、functionの最後に```return```という文があります。これは、結果を返す変数を指定するものです。```return a```とすると、変数aが結果として返ります。ここは複数にすることができて、その場合には```return a,b```などとなります。数学での関数では通常一つしか結果が出てきませんが、プログラムとしてはそこを一つと制限する必要はありませんので、複数結果返すことができます。
プログラムで数値計算する場合には多くの場合関数が一行で書けるとは限りませんので、このようにで囲って```function```と```end```で関数を定義します。

#### 3.3.2.3. 精度コントロール：If文の紹介
次に、nmaxをどこまで取るか、という問題を考えます。



以下執筆予定